#! /usr/local/bin/node

var fs = require('fs');
var path = require('path');

var VCS = '.myvcs';
var CWD = process.cwd();
var LOG = path.join(VCS, 'log');
var HEAD = path.join(VCS, 'head');

// Create VCS directory, head and log files
if (!fs.existsSync(VCS)) {
  fs.mkdirSync(VCS);
  fs.writeFileSync(HEAD, '');
  fs.writeFileSync(LOG, '[]');
}

function backup(message) {
  fs.mkdir(nextBackup());
  cpdir(CWD, latestBackup(), { cpTopLevel: true });

  message = message || '[No message]';
  writeLog(message);
  setHead(latestIndex());
}

function checkout(n) {
  if (!n) throw new Error('Checkout number not provided');
  var backup = path.join(CWD, VCS, n.toString(), path.basename(CWD));
  cleardir(CWD);
  cpdir(backup, CWD);
  setHead(n);
}

function current() {
  var data = fs.readFileSync(HEAD, { encoding: 'utf8' });
  return data;
}

/**
 * Copying files and directories
 */
function cpFile(fIn, fOut) {
  var data = fs.readFileSync(fIn, { encoding: 'utf8' });
  fs.writeFileSync(fOut, data);
}

function cpdir(dIn, dOut, options) {
  options = options || {};
  console.log('Copying contents:', dIn);

  if (options.cpTopLevel === true) {
    var dOut = path.join(dOut, path.basename(dIn));
    fs.mkdirSync(dOut);
  }

  var ls = fs.readdirSync(dIn);
  ls.forEach(function(file) {
    if (file === VCS) return;
    var fIn = path.join(dIn, file);
    var fOut = path.join(dOut, file);
    var stats = fs.lstatSync(fIn);

    if (stats.isDirectory()) {
      fs.mkdirSync(fOut);
      cpdir(fIn, fOut);
    } else if (stats.isFile()) {
      console.log('Copying file:', fIn);
      cpFile(fIn, fOut);
    }
  });
}

/**
 * Logging backups
 */
function readLog() {
  return fs.readFileSync(LOG, { encoding: 'utf8' });
}

function parseLog() {
  return JSON.parse(readLog());
}

function writeLog(message) {
  var data = {
    backup:  latestIndex(),
    parent:  current(),
    date:    new Date(),
    message: message
  };
  appendLogTop(LOG, data);
}

function appendLogTop(file, data) {
  var fileData = fs.readFileSync(file, { encoding: 'utf8' });
  var json = JSON.parse(fileData);
  json.unshift(data);
  fs.writeFileSync(file, JSON.stringify(json));
}

function printLog() {
  var backupList = parseLog();
  for (var b in backupList) {
    var backup  = 'Backup:  ' + backupList[b].backup;
    var date    = 'Date:    ' + backupList[b].date;
    var message = 'Message: ' + backupList[b].message;
    console.log([backup, date, message].join('\n'));
    console.log();
  }
}

/**
 * Clearing directories
 */
function cleardir(dir) {
  function dirFn(filepath) { fs.rmdirSync(filepath); }
  function fileFn(filepath) { fs.unlinkSync(filepath); }
  traverseWith(dir, dirFn, fileFn, { post: true });
}

/**
 * Traversing directory tree, applying dirFn and fileFn
 */
function traverseWith(dir, dirFn, fileFn, options) {
  options = options || {};
  var ls = fs.readdirSync(dir);

  ls.forEach(function(file) {
    if (file === VCS) return;
    var filepath = path.join(dir, file);
    var stats = fs.lstatSync(filepath);

    if (stats.isDirectory()) {
      if (options.pre === true) {
        dirFn(filepath);
      }
      traverseWith(filepath, dirFn, fileFn, options);
      if (options.post === true) {
        dirFn(filepath);
      }
    } else if (stats.isFile()) {
      fileFn(filepath);
    }
  });
}

/**
 * Backup helpers
 */
function latestIndex() {
  return fs.readdirSync(VCS).length - 2;
}

function latestBackup() {
  return path.join(CWD, VCS, latestIndex().toString());
}

function nextBackup() {
  return path.join(CWD, VCS, (latestIndex() + 1).toString());
}

function setHead(n) {
  fs.writeFileSync(HEAD, n);
}

/**
 * Command line processing
 */
var args = process.argv.slice(2);
switch (args[0]) {
  case 'backup':
    var message = args[2];
    backup(message);
    break;
  case 'checkout':
    checkout(args[1]);
    break;
  case 'latest':
    checkout(latestIndex());
    break;
  case 'current':
    console.log(current());
    break;
  case 'log':
    printLog();
    break;
  default:
    throw new Error('Invalid command');
}
